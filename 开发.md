#  前端
## 1 Ajax
## 1.1 ajax()方法

```javascript
$.ajax({
  url: "example.php",
  type: "POST",
  data: { name: "John", age: 30 },
  success: function(response){
    alert("Data saved: " + response);
  }
});
```
## 2 Vue
## 2.1 vue生命周期

- beforeCreate()：实例创建之前，数据观测和事件配置之前。
- created()：实例创建之后，数据观测和事件配置之后。 
- beforeMount()：实例挂载开始之前。
- mounted()：实例挂载之后。
- beforeUpdate()：数据更新时调用，发生在虚拟 DOM 打补丁之前。
- updated()：数据更新时调用，发生在虚拟 DOM 打补丁之后。
- beforeDestroy()：实例销毁之前。
- destroyed()：实例销毁之后。  

主要记住mounted(),vue的生命周期应用场景，主要是用来页面加载完毕时，发出异步请求，获取数据，渲染页面。   
实例：mounted()可以用来每次页面刷新以后，再获取结果以后，保持页面的状态。
```javascript
import Vue from 'vue'
const app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  },
  mounted() {
    console.log('mounted')
  }
})
```


# 后端
## 1 Maven
## 1.1 Maven作用
主要是用来管理Java项目的依赖包，自动化编译，自动化测试，项目管理等。其他项目可以直接导入POM.xml文件，通过Maven自动下载依赖包，编译，测试，打包等。
## 1.2Maven目录结构
- pom.xml：项目管理文件，包含项目基本信息，依赖管理，插件管理等。
- src：源码目录，包含java代码，资源文件等。
- target：编译输出目录，包含编译后的class文件，jar包等。
- lib：依赖jar包目录。
- web：Web资源目录，包含Web页面，jsp，html等。

## 1.3 Maven管理依赖包
```xml
  <dependencies>  
      <dependency>  
        <groupId>groupId</groupId>    
        <artifactId>artifactId</artifactId>
        <version>version</version>  
        <scope>scope</scope>
      </dependency>
  </dependencies>
```
groupId：依赖包的唯一标识，一般是域名倒写。  
artifactId：依赖包的名称。  
version：依赖包的版本号。  
scope：依赖包的作用范围，默认为compile，全局都可以  

## 1.4 Maven常用命令
- clean：清除目标目录。
- compile：编译项目。
- test：运行测试用例。
- package：打包项目。
- install：安装项目到本地仓库。
- deploy：发布项目到远程仓库。


## 1.5 Maven生命周期
生命周期，就是Maven执行时，会按照这个顺序执行。右侧可以看到图
- validate：验证项目是否正确。
- generate-sources：生成源代码。
- process-resources：处理资源文件。
- generate-test-sources：生成测试源代码。
- process-test-resources：处理测试资源文件。
- compile：编译源代码。
- process-classes：处理编译后的类文件。
- test-compile：编译测试源代码。
- process-test-classes：处理测试类文件。
- test：运行测试用例。  
- package：打包项目。

## 1.6 Maven相关问题
下载包时，出现错误：可能是存在残留的update文件，在本地仓库目录下打开cmd，执行命令，删除残留的update文件。
```
路径：E:\Software\Maven\apache-maven-4.0.0-rc-4
      E:\Soft_Files\Maven

del /s  *.lastUpdated 
``` 


## 2 JUnit
## 2.1 JUnit测试
断言测试, 用于测试代码的输出是否符合预期。
```java
import org.junit.Test;
import static org.junit.Assert.*;

public class CalculatorTest {
    @Test
    public void testAdd() {
        Calculator calculator = new Calculator();   //实例化对象
        int result = calculator.add(2, 3);    //调用方法
        assertEquals(ExpectedResult = 5, result);    //断言结果5, result的值
    }
}
```
## 2.2 JUnit常用断言
- assertEquals(expected, actual)：判断两个对象或值是否相等。
- assertTrue(condition)：判断条件是否为true。 
- assertFalse(condition)：判断条件是否为false。 
- assertNull(object)：判断对象是否为null。 
- assertNotNull(object)：判断对象是否不为null。 
- assertArrayEquals(expected, actual)：判断两个数组是否相等。 
- assertNotSame(expected, actual)：判断两个对象是否不相同。 
- assertSame(expected, actual)：判断两个对象是否相同。      

## 2.3 JUnit常见注解
- @Test：测试方法。  
- @Parameterized：参数化测试。   
- @ValueSource：提供测试数据。 
- @DisplayName：自定义测试名称。  
- @BeforeEach：在每个测试方法执行之前执行。  
- @AfterEach：在每个测试方法执行之后执行。  
- @Before：在测试方法执行之前执行。  
- @After：在测试方法执行之后执行。  

例如测试一个根据身份证号码判定是否为男性的脚本
  ```java
  import org.junit.jupiter.params.ParameterizedTest;
  import org.junit.jupiter.params.provider.CsvSource; 
  import static org.junit.jupiter.api.Assertions.*;

  public class GenderTest {
      @ParameterizedTest
      @ValueSource({"110101199001011234,M", "110101199001011235,F"})
      public void testGender(String idCard, String expected) {  
          Gender gender = new Gender();
          assertEquals(expected, gender.getGender(idCard));
      }
  }
  ```
  这里使用了@ParameterizedTest注解，@ValueSource注解提供测试数据，测试方法testGender()接收两个参数，第一个参数是身份证号码，第二个参数是期望的性别。

测试点击"Runtestwithcoverage"按钮，可以看到测试覆盖率。

## 3 HTTP
## 3.1 HTTP请求数据格式
请求行：请求方法  请求路径  HTTP版本  
请求头：
- Host：服务器域名或IP地址和端口号
- Connection：keep-alive或close
请求体： POST请求的数据，get请求没有请求体，get请求的数据在URL中，存在数据大小限制。post 请求的数据在请求体中，数据大小不限制。

## 3.2 HTTP请求数据
```java
import javax.servlet.http.HttpServletRequest;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController;
@Controller
public class RequestController {
    @RequestMapping("/request")
    public String request(HttpServletRequest request) {
        // 1. 获取请求方式
        String method = request.getMethod(); // GET
        System.out.println("请求方式：" + method);

        // 2. 获取请求url地址
        String url = request.getRequestURL().toString(); // http://localhost:8080/request
        System.out.println("请求url地址：" + url);

        String uri = request.getRequestURI(); // /request
        System.out.println("请求uri地址：" + uri);

        // 3. 获取请求协议
        String protocol = request.getProtocol(); // HTTP/1.1
        System.out.println("请求协议：" + protocol);

        // 4. 获取请求参数 - name, age
        String name = request.getParameter("name");
        String age = request.getParameter("age");
        System.out.println("name：" + name + ", age：" + age);

        // 5. 获取请求头 - Accept
        String cookie = request.getHeader("cookie");
        System.out.println("cookie ：" + cookie);

        return "OK";
    }
}
```
## 3.3 HTTP响应数据格式
响应行：HTTP版本  状态码  状态描述  
响应头：
- Content-Type：响应数据的类型和编码
- Content-Length：响应数据的长度
响应体：响应数据，可以是文本，也可以是二进制数据。

响应状态码：  
1xx：响应中临时状态，表示请求已被接受，正在处理。  
2xx：成功，表示请求已成功被服务器接收、理解、并接受。   
3xx：重定向，表示需要进行附加操作，以完成请求。两次请求反应，请求A后续请求B，B的响应码为3xx，则B的请求头中包含Location，Location的值为A的响应头中的Location的值。   
4xx：客户端错误，表示请求包含语法错误或无法完成请求。如请求了不存在的资源404.    
5xx：服务器错误，表示服务器在处理请求的过程中发生了错误。如服务器超时504.服务器错误，如500.


## 3.4 HTTP响应数据
```java
@RestController
public class ResponseController {
    @RequestMapping("/response2")
    public ResponseEntity<String> response2(){
        return ResponseEntity
                .status(401) // 响应状态码
                .header("name", "javaweb-ai") // 响应头
                .body("<h1>hello response</h1>"); // 响应体
    }
}
```

## 3.5 HTTP一些包
RestController //用到了ResponseBody ->作用:将controller返回值直接作为响应体的数据直接响应;返団值是对象/集合->json

## 4 web基础
## 4.1 三层架构
- controller: 控制层，负责处理用户请求，调用service层的业务逻辑。   
- service：服务层，负责处理业务逻辑，调用数据访问层。   
- dao：数据访问层，负责处理数据访问，包括数据增删改查。  

## 4.2 分层解耦

在实现类上面加上注解@component，即当前类交给IOC容器管理，不是在接口上加入@component注解，而是在实现类上加入@component注解。  
@Autowired //应用程序运行时，会自动的査询该类型的bean对象,并赋值给该成员变量
例如：
```java
@Service  
public class UserService {  
    @Autowired  
    private UserDao userDao; 
    //原始的话， private UserDao userDao = new UserDao();   
}  
```
相当于创建一个A类，B类要使用A类，那么B类就要在类里面添加@Autowired注解，并指定A类，不需要new A类了


## 4.3 bean的声明
申明bean的注解包含下面四个   
@Component //将类交给IOC容器管理,衍生出其他三种，分别作用在不同的层级上：   
@Controller //控制器 controller   
@Service //服务层 service   
@Repository //数据访问层 dao  

注意事项   
- 在Springboot集成web开发中，声明控制器bean只能用@Controller.     
- 声明bean的注解要想生效，需要被扫描到，启动类默认扫描当前包及其子包

## 4.4基于Autowired注解的三种方式
### 4.4.1 属性注入
1.属性注入
优点：代码简洁、方便快速开发。  
缺点：隐藏了类之间的依赖关系、可能会破坏类的封装性。
```Java
@RestController
public class UserController {
    @Autowired
    private UserService userService;
    // ......
}
```
2：构造函数注入  
优点：能清晰地看到类的依赖关系，提高了代码的安全性。  
缺点：代码繁琐，如果构造参数过多，可能会导致构造函数臃肿。  
注意：如果只有一个构造函数，@Autowired 注解可以省略。  
```Java
@RestController
public class UserController {
    private final UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }
}
```
3：setter 注入
优点：保持了类的封装性，依赖关系更清晰。  
缺点：需要额外编写 setter 方法，增加了代码量。 
```Java
@RestController
public class UserController {
    private UserService userService;

    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
}
```
总结：
1，2方法常用   
属性注入：简单快捷，但不利于维护和测试。   
构造函数注入：推荐使用，尤其在 Spring Boot 中，适合不可变对象。  
setter 注入：适用于可选依赖或非必需依赖场景。  

### 4.4.2 多个注入的解决办法

1.依赖注入的注解  
- @Autowired: 默认按照类型自动装配  
- 如果同类类型的bean存在多个:  
  - @Primary  
  - @Autowired + @Qualifier  
  - @Resource  

2.@Resource 与 @Autowired区别？  
- @Autowired是Spring框架提供的注解，而@Resource是JavaEE规范提供的  
- @Autowired默认是按照类型注入，而@Resource默认是按照名称注入

## 5 Mysql
## 5.1 远程访问数据库
```shell
==> mysql -h192.168.1.100 -P3306 -uroot -p
==> 123456 //输入密码
```

## 6 Mybatis
## 6.1 Mybatis连接数据库
在application.properties中配置数据库连接信息
```application.properties
#配置数据源
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=123456

#配置德鲁伊数据库连接池，默认原始的是使用追光者的连接池，这里使用德鲁伊，同时还要在pop文件里面配置相关的信息
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource

#配置日志输出
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
```

```xml
<!--配置Druid数据源-->
<dependency>
  <groupld>com.alibaba</groupld>
  <artifactld>druid-spring-boot-starter</artifactld>
  <version>1.2.19</version>
</dependency>
```
## 6.2 Mapper接口
```java
@Mapper
public interface UserMapper {
  @Select("SELECT * FROM user")
  public List<User> selectAll();
}
```

## 6.3 Mybatis中#{}与${}符号的区别
- #{}：预编译处理，将sql中的参数替换为?号，防止sql注入。  
- ${}：动态sql，在sql中拼接变量，不预编译，不安全。  

## 6.4 XML映射文件定义规则
文件在resources目录下
a. XML文件名称与Mapper接口名称一致，并且放置在相同包下（同包同名）。  
b. XML文件的namespace属性为Mapper接口全限定名一致。  
c. XML文件中sql语句的id与Mapper接口中的方法名一致。  

![image.png](Developer_images/1.png)

如果没有按照上面的规则进行配置，那也可以在application.properties中配置mybatis的相关信息。
![alt text](Developer_images/2.png)

## 6.5 properties文件转为yml文件
![alt text](Developer_images/3.png)

## 7 增删改查实战
## 7.1 查询相关信息
先进入controller，调用service层的相关方法，service层调用dao层的相关方法，dao层查询数据库，返回结果给service层，service层返回给controller层，controller层返回给前端。   
@Restcontroller注解：将类交给IOC容器管理，返回的时候转化为json格式
![alt text](Developer_images/4.png)
设置驼峰命名映射相关
在application.properties中添加如下内容：
mybatis.configuration.map-underscore-to-camel-case=true   
解决数据库表格中的名字和实体类中的属性名不一致问题，如：user_name和userName
 ![alt text](Developer_images/5.png)

## 7.2 删除
![alt text](Developer_images/7.png)
![alt text](Developer_images/8.png)

## 7.3 新增
![alt text](Developer_images/9.png)
接受json数据需要注意的事情： 
![alt text](Developer_images/10.png)

## 7.4 修改
根据id查询用户信息
![alt text](Developer_images/11.png)
注意事项： 
![alt text](Developer_images/12.png)
修改用户信息：  
![alt text](Developer_images/13.png)

## 8 Nigx代理
## 8.1 反向代理相关
不直接访问服务器，通过Ngix代理访问服务器，Ngix代理服务器，将请求转发给后端服务器。
![alt text](Developer_images/6.png)


## 9 Logback
## 9.1 日志配置
配置的xml文件放在resources目录下
![alt text](Developer_images/14.png)
## 9.2 优化后的格式  
![alt text](Developer_images/15.png)   
注意事项：  
![alt text](Developer_images/16.png)

## 10 员工管理
## 10.1 分页查询
原始方法
![alt text](Developer_images/17.png)

优化方法
使用插件pagehelper帮助我们分页，只需要进行查询即可，不用管分页的操作，这里面主要三个步骤，第一个在pom文件里面加入差价，第二部重新写一下mapper里面查询语句，不需要分页查询的信息，第三步就是在service里面写分页查询的代码
![alt text](Developer_images/18.png)
srvice的impl层具体实现细节如下：
![alt text](Developer_images/19.png)
注意事项：
- 1、定义的sql语句结尾不能加入分号“；”
- 2、PageHelper仅仅能对紧跟在其后的第一个查询语句进行分页处理，只能进行一次分页查询处理，多的话不可以

## 10.2 条件分页查询
controller层接收参数，需要注明接收参数的格式是什么样子的，yyyy-MM-dd格式的日期类型，这里需要用到@DateTimeFormat注解,mapper层由于sql语句太长了，所以在resources目录下创建一个xxx.mapper.xml文件，将sql语句进行封装，service层调用mapper层进行查询，controller层返回给前端。
![alt text](Developer_images/20.png)  

优化1：
接受的参数有点多，定义一个接受类，将参数封装在里面，然后controler层需要修改，mapper也需要修改，impl层也需要修改，sql语句不需要修改
![alt text](Developer_images/21.png)  
![alt text](Developer_images/22.png)  
![alt text](Developer_images/23.png)  
![alt text](Developer_images/24.png) 

优化2：动态SQL查询，名字匹配的时候要使用concat拼接，不然报错，注意是关键字where，这里面表示选取符合条件的查询语句，如果都不合适，则不会带入where的查询语句

![alt text](Developer_images/25.png) 

## 10.3保存员工基本信息
接受的参数为json格式，所以在前面加入一个@RequestBody注解，将json数据转化为对象，然后调用service层的保存方法。没有创建与更新时间，需要修改一下创建与更新时间，sql语句要注意驼峰命名。
![alt text](Developer_images/26.png) 

## 10.4批量保存员工工作经历
核心要点：
- 1：在插入数据的时候，需要插入索引，但是索引是员工基本信息的id，需要我们去系统里面查询，因此在Mapper实现层中，需要加入注解@Options,来获取相关的信息,这个mapper为保存员工信息的mapper,相当与通过这个保存，再来查询相关的id,然后在impl层中，需要遍历每次插入的id信息，进行赋值，传输到mapper层进行保存
- 2：编写sql时候由于要插入多条数据，所以需要使用foreach标签，将数据进行循环，里面的item表示循环的元素，index表示索引，open表示循环开始需要加入什么，close表示循环结束需要加入的东西，separator表示循环中需要加入什么，这里就需要加入“，”，确保能够插入多条数据
![alt text](Developer_images/27.png) 
![alt text](Developer_images/28.png)  //mapper注解相关
![alt text](Developer_images/29.png)  //impl层具体实现细节
![alt text](Developer_images/30.png)  

## 10.5事务操作 
Spring事务管理的注解@Transactional的作用是什么，可以加在什么位置？  
@Transactional：会在方法运行之前，开启事务，运行完毕后，根据运行的结果，来提交或回滚事务。用来确保事务要么全部成功，要么全部失败。  
位置：方法上、类上、接口上


1. 事务的传播行为控制的是什么？
一个事务方法，调用另外一个事务方法时，事务应该如何控制（加入？新建？...）
2. 常见的传播行为及应用场景？
REQUIRED：大部分场景
REQUIRES_NEW：希望两个方法在独立的事务中运行，互不影响
如下所示：默认情况下使用的是REQUIRED，但是在finally里面，不论前面事务操作是否有异常，我都需要记录这个事务，因此在impl具体实验inseretlog方法里面，需要在前面加上注解@Transactional(propagation = Propagation.REQUIRES_NEW)，表示开启一个新的事务，这样就可以保证前面操作的事务不受影响，都会进行日志记录
![alt text](Developer_images/31.png)  

## 10.6 数据存储在阿里云，使用oss云存储
这个里面新构建一个controller，用来上传文件，然后调用oss的相关方法，将文件上传到oss，然后将oss的地址返回给前端，前端可以直接访问oss的地址进行下载，然后前端将文件的地址与用户其他信息保存为json格式发送给后端，这样可以将数据写入后台数据中。  
![alt text](Developer_images/32.png)  
这里新写了一个类关于处理阿里云数据库云的oss，ailiyunOSSOperations,前面的可以用阿里云相关介绍文档
![alt text](Developer_images/33.png)
![alt text](Developer_images/34.png)  
优化：
- 优化1：参数配置优化：上面的endpoint,bucketName,会存在变动，所以我们将会变动的信息存在yml配置文件中，然后通过@Value注解获取值   
![alt text](Developer_images/35.png)   
- 优化2：如果数据过多，需要加入的注解value过多，不便于维护，因此直接新建一个专门存储的类，将相关信息都放在里面，然后通过@Autowired注解注入到controller中，这样可以减少代码量，提高代码的可读性。这里要使用@ConfigurationProperty注解前缀ailiyun.oss，表示是阿里云的oss配置信息，然后在yml文件中配置相关信息。  
![alt text](Developer_images/36.png)  


## 10.7 批量删除员工信息
controller层接收参数，impl层进行批量删除,mapper层进行sql语句的编写,这里需要删除两张表，一个是员工个人信息，一个是员工的工作经历
![alt text](Developer_images/37.png)   
![alt text](Developer_images/38.png)   

## 10.8 员工信息修改
第一步需要查询相关信息，进行信息回显，这里主要难点在于，查询的员工信息只有一条，但是工作经历会存在多条，这个工作经历会放在list集合中，但是普通的sql语句会显示多条数据，因此需要把这个多条数据存储在集合中，然后返回给前端，这个mapper中的sql需要好好写一下  
contrller层如下：
![alt text](Developer_images/40.png)    
impl层如下
![alt text](Developer_images/41.png)   
mapper层如下
![alt text](Developer_images/39.png) 
- 1.问：Mybatis中封装查询结果，什么时候用 resultType，什么时候用resultMap？  
如果查询返回的字段名与实体的属性名可以直接对应上，用resultType。
如果查询返回的字段名与实体的属性名对应不上，或实体属性比较复杂，可以通过resultMap手动封装。

## 10.9 员工信息更新
员工的基本信息直接用更新，工作经历用删除，然后重新插入，删除的时候使用上面批量删除员工的接口，会删除工作经历表，插入也使用之前的接口，，这里需要新写的主要是更新的mapper,
![impl层](Developer_images/42.png) 
![mapper层sql代码](Developer_images/43.png)  
- 优化：上面的sql拓展性差，如果我只更新其中一两条数据，其他的没有数据，因此会被传为null,导致更新失败，因此需要执行动态sql,利用if判断，其中使用了set标签，他会自动生成set关键字，同时会自动删除更新字段后多余的逗号“，”
![优化sql](Developer_images/44.png)  

## 11 全局异常处理
这里全局异常处理主要是处理重复信息的输入，
1. 如何定义一个全局异常处理器？
@RestControllerAdvice = @ControllerAdvice + @ResponseBody
@ExceptionHandler
说明：@RestControllerAdvice 是Spring Boot中用于定义全局异常处理器的注解，它结合了 @ControllerAdvice和@ResponseBody的功能。
使用 @ExceptionHandler 注解可以指定处理特定异常的方法，该方法会返回一个响应体（如 JSON 格式），适用于RESTful接口的异常统一处理。
![alt text](Developer_images/45.png)  


## 12 统计结果
## 12.1统计各职位人数
![三层架构细节](Developer_images/46.png)   

## 12.2统计男女人数
![三层架构细节](Developer_images/47.png)    

##  13 登录认证
## 13.1 cookie会话
![alt text](Developer_images/48.png)
会话过程中，保存cookie信息,方便访问其他内容的时候，确保用户是登录的    
![alt text](Developer_images/49.png)    
## 13.2 session会话
![alt text](Developer_images/50.png)
以上两种方法的缺点：
![alt text](Developer_images/51.png)    
## 13.3 令牌会话
使用jwt令牌的时候，需要在pom文件中添加dependency依赖
```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
``` 
![优缺点](Developer_images/52.png)
设置生成令牌：
![生成令牌](Developer_images/53.png)
![解析令牌](Developer_images/54.png)
小结：
![小结](Developer_images/55.png) 

## 13.4 登录认证流程
这里只展示了controler层,需要提前在utils里面编写好generateToken方法，里面封装两个方法，一个是生成令牌，一个是解析令牌，以上面53，54的代码为基础，修改一下
![登录认证流程](Developer_images/56.png)  

## 13.5 filter过滤器
![filter拦截器开发步骤](Developer_images/57.png)  
![filter拦截器代码](Developer_images/58.png)  
![filter拦截器代码](Developer_images/59.png)  
这里面需要在启动项加入注解@ServletComponentScan，表示扫描filter拦截器，然后在filter拦截器里面编写相关代码，，这里新建了一个相关的类，这里面需要注意的是，filter拦截器只能拦截到请求，不能拦截到响应，因此不能直接返回json数据，需要通过response对象来返回json数据。拦截没问题的话，需要放行，这里需要使用filterChain.doFilter(request,response);

## 13.6 filter校验令牌
需要加入注解，包含需要校验的路径@webFilter(urlPatterns = "/*")
这里要新注册一个类，重写编写拦截器，只要写中间的doFilter方法，然后在这个方法里面校验令牌，如果校验成功，就放行，如果校验失败，就返回错误信息。
![校验令牌](Developer_images/60.png)   
![校验令牌](Developer_images/61.png)    

## 13.7 interceptor拦截器
![interceptor拦截器在config中配置](Developer_images/62.png)   
![interceptor拦截器代码](Developer_images/63.png)   
![整体流程](Developer_images/64.png)   

## 13.8 interceptor校验令牌
令牌注册在config中，这里主要调用令牌校验的类，方便目标代码简介,这里的返回值为布尔值，true与false，与上面filter校验返回值不一样
![config中编写的注册](Developer_images/65.png)   
![interceptor校验令牌代码](Developer_images/66.png)  
![interceptor校验令牌代码](Developer_images/67.png)   
![interceptor校验令牌代码](Developer_images/68.png)   

## 13.9 拦截路径
![拦截器拦截路径说明](Developer_images/69.png)   
![拦截器与过滤器执行流程及区别](Developer_images/70.png)   

## 14 AOP
## 14.1统计耗时
![AOP统计耗时](Developer_images/71.png)   
## 14.2 AOP核心概念
![AOP核心概念](Developer_images/72.png)   
## 14.3 通知类型
![通知类型](Developer_images/73.png)   
