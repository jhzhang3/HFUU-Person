#  前端
## 1 Ajax
## 1.1 ajax()方法

```javascript
$.ajax({
  url: "example.php",
  type: "POST",
  data: { name: "John", age: 30 },
  success: function(response){
    alert("Data saved: " + response);
  }
});
```
## 2 Vue
## 2.1 vue生命周期

- beforeCreate()：实例创建之前，数据观测和事件配置之前。
- created()：实例创建之后，数据观测和事件配置之后。 
- beforeMount()：实例挂载开始之前。
- mounted()：实例挂载之后。
- beforeUpdate()：数据更新时调用，发生在虚拟 DOM 打补丁之前。
- updated()：数据更新时调用，发生在虚拟 DOM 打补丁之后。
- beforeDestroy()：实例销毁之前。
- destroyed()：实例销毁之后。  

主要记住mounted(),vue的生命周期应用场景，主要是用来页面加载完毕时，发出异步请求，获取数据，渲染页面。   
实例：mounted()可以用来每次页面刷新以后，再获取结果以后，保持页面的状态。
```javascript
import Vue from 'vue'
const app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  },
  mounted() {
    console.log('mounted')
  }
})
```


# 后端
## 1 Maven
## 1.1 Maven作用
主要是用来管理Java项目的依赖包，自动化编译，自动化测试，项目管理等。其他项目可以直接导入POM.xml文件，通过Maven自动下载依赖包，编译，测试，打包等。
## 1.2Maven目录结构
- pom.xml：项目管理文件，包含项目基本信息，依赖管理，插件管理等。
- src：源码目录，包含java代码，资源文件等。
- target：编译输出目录，包含编译后的class文件，jar包等。
- lib：依赖jar包目录。
- web：Web资源目录，包含Web页面，jsp，html等。

## 1.3 Maven管理依赖包
```xml
  <dependencies>  
      <dependency>  
        <groupId>groupId</groupId>    
        <artifactId>artifactId</artifactId>
        <version>version</version>  
        <scope>scope</scope>
      </dependency>
  </dependencies>
```
groupId：依赖包的唯一标识，一般是域名倒写。  
artifactId：依赖包的名称。  
version：依赖包的版本号。  
scope：依赖包的作用范围，默认为compile，全局都可以  

## 1.4 Maven常用命令
- clean：清除目标目录。
- compile：编译项目。
- test：运行测试用例。
- package：打包项目。
- install：安装项目到本地仓库。
- deploy：发布项目到远程仓库。


## 1.5 Maven生命周期
生命周期，就是Maven执行时，会按照这个顺序执行。右侧可以看到图
- validate：验证项目是否正确。
- generate-sources：生成源代码。
- process-resources：处理资源文件。
- generate-test-sources：生成测试源代码。
- process-test-resources：处理测试资源文件。
- compile：编译源代码。
- process-classes：处理编译后的类文件。
- test-compile：编译测试源代码。
- process-test-classes：处理测试类文件。
- test：运行测试用例。  
- package：打包项目。

## 1.6 Maven相关问题
下载包时，出现错误：可能是存在残留的update文件，在本地仓库目录下打开cmd，执行命令，删除残留的update文件。
```
路径：E:\Software\Maven\apache-maven-4.0.0-rc-4
      E:\Soft_Files\Maven

del /s  *.lastUpdated 
``` 


## 2 JUnit
## 2.1 JUnit测试
断言测试, 用于测试代码的输出是否符合预期。
```java
import org.junit.Test;
import static org.junit.Assert.*;

public class CalculatorTest {
    @Test
    public void testAdd() {
        Calculator calculator = new Calculator();   //实例化对象
        int result = calculator.add(2, 3);    //调用方法
        assertEquals(ExpectedResult = 5, result);    //断言结果5, result的值
    }
}
```
## 2.2 JUnit常用断言
- assertEquals(expected, actual)：判断两个对象或值是否相等。
- assertTrue(condition)：判断条件是否为true。 
- assertFalse(condition)：判断条件是否为false。 
- assertNull(object)：判断对象是否为null。 
- assertNotNull(object)：判断对象是否不为null。 
- assertArrayEquals(expected, actual)：判断两个数组是否相等。 
- assertNotSame(expected, actual)：判断两个对象是否不相同。 
- assertSame(expected, actual)：判断两个对象是否相同。      

## 2.3 JUnit常见注解
- @Test：测试方法。  
- @Parameterized：参数化测试。   
- @ValueSource：提供测试数据。 
- @DisplayName：自定义测试名称。  
- @BeforeEach：在每个测试方法执行之前执行。  
- @AfterEach：在每个测试方法执行之后执行。  
- @Before：在测试方法执行之前执行。  
- @After：在测试方法执行之后执行。  

例如测试一个根据身份证号码判定是否为男性的脚本
  ```java
  import org.junit.jupiter.params.ParameterizedTest;
  import org.junit.jupiter.params.provider.CsvSource; 
  import static org.junit.jupiter.api.Assertions.*;

  public class GenderTest {
      @ParameterizedTest
      @ValueSource({"110101199001011234,M", "110101199001011235,F"})
      public void testGender(String idCard, String expected) {  
          Gender gender = new Gender();
          assertEquals(expected, gender.getGender(idCard));
      }
  }
  ```
  这里使用了@ParameterizedTest注解，@ValueSource注解提供测试数据，测试方法testGender()接收两个参数，第一个参数是身份证号码，第二个参数是期望的性别。

测试点击"Runtestwithcoverage"按钮，可以看到测试覆盖率。

## 3 HTTP
## 3.1 HTTP请求数据格式
请求行：请求方法  请求路径  HTTP版本  
请求头：
- Host：服务器域名或IP地址和端口号
- Connection：keep-alive或close
请求体： POST请求的数据，get请求没有请求体，get请求的数据在URL中，存在数据大小限制。post 请求的数据在请求体中，数据大小不限制。

## 3.2 HTTP请求数据
```java
import javax.servlet.http.HttpServletRequest;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController;
@Controller
public class RequestController {
    @RequestMapping("/request")
    public String request(HttpServletRequest request) {
        // 1. 获取请求方式
        String method = request.getMethod(); // GET
        System.out.println("请求方式：" + method);

        // 2. 获取请求url地址
        String url = request.getRequestURL().toString(); // http://localhost:8080/request
        System.out.println("请求url地址：" + url);

        String uri = request.getRequestURI(); // /request
        System.out.println("请求uri地址：" + uri);

        // 3. 获取请求协议
        String protocol = request.getProtocol(); // HTTP/1.1
        System.out.println("请求协议：" + protocol);

        // 4. 获取请求参数 - name, age
        String name = request.getParameter("name");
        String age = request.getParameter("age");
        System.out.println("name：" + name + ", age：" + age);

        // 5. 获取请求头 - Accept
        String cookie = request.getHeader("cookie");
        System.out.println("cookie ：" + cookie);

        return "OK";
    }
}
```
## 3.3 HTTP响应数据格式
响应行：HTTP版本  状态码  状态描述  
响应头：
- Content-Type：响应数据的类型和编码
- Content-Length：响应数据的长度
响应体：响应数据，可以是文本，也可以是二进制数据。

响应状态码：  
1xx：响应中临时状态，表示请求已被接受，正在处理。  
2xx：成功，表示请求已成功被服务器接收、理解、并接受。   
3xx：重定向，表示需要进行附加操作，以完成请求。两次请求反应，请求A后续请求B，B的响应码为3xx，则B的请求头中包含Location，Location的值为A的响应头中的Location的值。   
4xx：客户端错误，表示请求包含语法错误或无法完成请求。如请求了不存在的资源404.    
5xx：服务器错误，表示服务器在处理请求的过程中发生了错误。如服务器超时504.服务器错误，如500.


## 3.4 HTTP响应数据
```java
@RestController
public class ResponseController {
    @RequestMapping("/response2")
    public ResponseEntity<String> response2(){
        return ResponseEntity
                .status(401) // 响应状态码
                .header("name", "javaweb-ai") // 响应头
                .body("<h1>hello response</h1>"); // 响应体
    }
}
```

## 3.5 HTTP一些包
RestController //用到了ResponseBody ->作用:将controller返回值直接作为响应体的数据直接响应;返団值是对象/集合->json

## 4 web基础
## 4.1 三层架构
- controller: 控制层，负责处理用户请求，调用service层的业务逻辑。   
- service：服务层，负责处理业务逻辑，调用数据访问层。   
- dao：数据访问层，负责处理数据访问，包括数据增删改查。  

## 4.2 分层解耦

在实现类上面加上注解@component，即当前类交给IOC容器管理，不是在接口上加入@component注解，而是在实现类上加入@component注解。  
@Autowired //应用程序运行时，会自动的査询该类型的bean对象,并赋值给该成员变量
例如：
```java
@Service  
public class UserService {  
    @Autowired  
    private UserDao userDao; 
    //原始的话， private UserDao userDao = new UserDao();   
}  
```
相当于创建一个A类，B类要使用A类，那么B类就要在类里面添加@Autowired注解，并指定A类，不需要new A类了


## 4.3 bean的声明
申明bean的注解包含下面四个   
@Component //将类交给IOC容器管理,衍生出其他三种，分别作用在不同的层级上：   
@Controller //控制器 controller   
@Service //服务层 service   
@Repository //数据访问层 dao  

注意事项   
- 在Springboot集成web开发中，声明控制器bean只能用@Controller.     
- 声明bean的注解要想生效，需要被扫描到，启动类默认扫描当前包及其子包

## 4.4基于Autowired注解的三种方式
### 4.4.1 属性注入
1.属性注入
优点：代码简洁、方便快速开发。  
缺点：隐藏了类之间的依赖关系、可能会破坏类的封装性。
```Java
@RestController
public class UserController {
    @Autowired
    private UserService userService;
    // ......
}
```
2：构造函数注入  
优点：能清晰地看到类的依赖关系，提高了代码的安全性。  
缺点：代码繁琐，如果构造参数过多，可能会导致构造函数臃肿。  
注意：如果只有一个构造函数，@Autowired 注解可以省略。  
```Java
@RestController
public class UserController {
    private final UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }
}
```
3：setter 注入
优点：保持了类的封装性，依赖关系更清晰。  
缺点：需要额外编写 setter 方法，增加了代码量。 
```Java
@RestController
public class UserController {
    private UserService userService;

    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
}
```
总结：
1，2方法常用   
属性注入：简单快捷，但不利于维护和测试。   
构造函数注入：推荐使用，尤其在 Spring Boot 中，适合不可变对象。  
setter 注入：适用于可选依赖或非必需依赖场景。  

### 4.4.2 多个注入的解决办法

1.依赖注入的注解  
- @Autowired: 默认按照类型自动装配  
- 如果同类类型的bean存在多个:  
  - @Primary  
  - @Autowired + @Qualifier  
  - @Resource  

2.@Resource 与 @Autowired区别？  
- @Autowired是Spring框架提供的注解，而@Resource是JavaEE规范提供的  
- @Autowired默认是按照类型注入，而@Resource默认是按照名称注入

## 5 Mysql
## 5.1 远程访问数据库
```shell
==> mysql -h192.168.1.100 -P3306 -uroot -p
==> 123456 //输入密码
```

## 6 Mybatis
## 6.1 Mybatis连接数据库
在application.properties中配置数据库连接信息
```application.properties
#配置数据源
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=123456

#配置德鲁伊数据库连接池，默认原始的是使用追光者的连接池，这里使用德鲁伊，同时还要在pop文件里面配置相关的信息
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource

#配置日志输出
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
```

```xml
<!--配置Druid数据源-->
<dependency>
  <groupld>com.alibaba</groupld>
  <artifactld>druid-spring-boot-starter</artifactld>
  <version>1.2.19</version>
</dependency>
```
## 6.2 Mapper接口
```java
@Mapper
public interface UserMapper {
  @Select("SELECT * FROM user")
  public List<User> selectAll();
}
```

## 6.3 Mybatis中#与$符号的区别
- #{}：预编译处理，将sql中的参数替换为?号，防止sql注入。  
- ${}：动态sql，在sql中拼接变量，不预编译，不安全。  

## 6.4 XML映射文件定义规则
文件在resources目录下
a. XML文件名称与Mapper接口名称一致，并且放置在相同包下（同包同名）。  
b. XML文件的namespace属性为Mapper接口全限定名一致。  
c. XML文件中sql语句的id与Mapper接口中的方法名一致。  

![image.png](Developer_images/1.png)

如果没有按照上面的规则进行配置，那也可以在application.properties中配置mybatis的相关信息。
![alt text](Developer_images/2.png)

## 6.5 properties文件转为yml文件
![alt text](Developer_images/3.png)

## 7 增删改查实战
## 7.1 查询相关信息
先进入controller，调用service层的相关方法，service层调用dao层的相关方法，dao层查询数据库，返回结果给service层，service层返回给controller层，controller层返回给前端。   
@Restcontroller注解：将类交给IOC容器管理，返回的时候转化为json格式
![alt text](Developer_images/4.png)
设置驼峰命名映射相关
在application.properties中添加如下内容：
mybatis.configuration.map-underscore-to-camel-case=true   
解决数据库表格中的名字和实体类中的属性名不一致问题，如：user_name和userName
 ![alt text](Developer_images/5.png)

## 7.2 删除
![alt text](Developer_images/7.png)
![alt text](Developer_images/8.png)

## 7.3 新增
![alt text](Developer_images/9.png)
接受json数据需要注意的事情： 
![alt text](Developer_images/10.png)

## 7.4 修改
根据id查询用户信息
![alt text](Developer_images/11.png)
注意事项： 
![alt text](Developer_images/12.png)
修改用户信息：  
![alt text](Developer_images/13.png)

## 8 Nigx代理
## 8.1 反向代理相关
不直接访问服务器，通过Ngix代理访问服务器，Ngix代理服务器，将请求转发给后端服务器。
![alt text](Developer_images/6.png)


## 9 Logback
## 9.1 日志配置
配置的xml文件放在resources目录下
![alt text](Developer_images/14.png)
## 9.2 优化后的格式  
![alt text](Developer_images/15.png)  
注意事项：  
![alt text](Developer_images/16.png)